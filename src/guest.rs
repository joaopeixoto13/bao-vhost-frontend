// Copyright (c) Bao Project and Contributors. All rights reserved.
//          João Peixoto <joaopeixotooficial@gmail.com>
//
// SPDX-License-Identifier: Apache-2.0

//! The 'Guest' module represents the primary working entity, acting as a core entity managing
//! I/O interactions within the I/O Request Management System through the Bao Device Model.
//! Also, it manages a collection of devices associated with the guest and employs a dedicated
//! thread to manage and process I/O events generated by devices via the Device Model.
//!
//! # Architecture:
//!
//! Guest
//!
//!│
//!
//!├── ID
//!
//!├── Device Model Instance
//!
//!├── Collection of Devices
//!
//!│   ├── Device 1
//!
//!│   ├── Device 2
//!
//!│   └── ... (more devices)
//!
//!└── I/O Event Handling Thread

use std::{
    sync::{Arc, Mutex},
    thread::{Builder, JoinHandle},
};

use super::{device::BaoDevice, devicemodel::BaoDeviceModel};
use bao_sys::{defines::*, error::*, types::*};

/// Represents a collection of BaoDevices.
#[derive(Default)]
struct GuestDevices(Vec<Arc<BaoDevice>>);

impl GuestDevices {
    /// Pushes a new device to the collection.
    ///
    /// # Arguments
    ///
    /// * `dev` - A cloned Arc of the BaoDevice to be pushed to the collection.
    fn push(&mut self, dev: Arc<BaoDevice>) {
        self.0.push(dev);
    }

    /// Removes a BaoDevice with the specified device address from the collection.
    ///
    /// # Arguments
    ///
    /// * `dev_addr` - The address of the device to be removed.
    ///
    /// # Returns
    ///
    /// * `Arc<BaoDevice>` - The removed BaoDevice wrapped in an Arc.
    fn remove(&mut self, dev_addr: u64) -> Arc<BaoDevice> {
        // Find the index of the device with the specified dev_id
        let index = self.0.iter().position(|dev| dev.addr == dev_addr).unwrap();

        // Remove the device from the vector and return it wrapped in an Arc
        self.0.remove(index)
    }

    /// Handles I/O events for the BaoDevice collection based on the given BaoIoRequest.
    /// If the request address falls within a device's address range, triggers the corresponding device's io_event.
    fn io_event(&self, req: &mut BaoIoRequest) -> Result<()> {
        for dev in &self.0 {
            // Check if the request address falls within the address range of the current device
            if req.addr >= dev.addr && req.addr < dev.addr + VIRTIO_MMIO_IO_SIZE {
                // Trigger the io_event for the device and return Ok(()) on success
                match dev.io_event(req) {
                    Ok(()) => {
                        return Ok(());
                    }
                    Err(err) => {
                        return Err(err);
                    }
                }
            }
        }

        // Device not found
        Err(Error::DeviceNotFound)
    }

    /// Checks if the BaoDevice collection is empty.
    ///
    /// # Returns
    ///
    /// * `bool` - A boolean indicating whether the collection is empty.
    fn is_empty(&self) -> bool {
        self.0.is_empty()
    }
}

/// Represents a BaoGuest.
///
/// # Attributes
///
/// * `id` - The ID of the guest.
/// * `dm` - A Mutex-protected BaoDeviceModel instance.
/// * `devices` - A Mutex-protected collection of guest devices.
/// * `handle` - A Mutex-protected handle for the guest's thread to process the I/O events.
/// * `enabled` - A Mutex-protected boolean indicating whether the guest is enabled.
pub struct BaoGuest {
    pub id: u16,
    pub dm: Mutex<BaoDeviceModel>,
    devices: Mutex<GuestDevices>,
    handle: Mutex<Option<JoinHandle<Result<()>>>>,
    enabled: Mutex<bool>,
}

// Implementing `Send` trait unsafely for `BaoGuest`.
// This indicates it's considered safe to transfer `BaoGuest` instances between threads,
// enabling transferring ownership of a `BaoGuest` instance between threads.
// As the `BaoGuest` instance is protected by a Mutex, it's safe to transfer ownership of it between threads.
unsafe impl Send for BaoGuest {}

// Implementing `Sync` trait unsafely for `BaoGuest`.
// This indicates it's considered safe to share references of `BaoGuest` between threads.
// As the `BaoGuest` instance is protected by a Mutex, it's safe to share references of it between threads.
unsafe impl Sync for BaoGuest {}

impl BaoGuest {
    /// Creates a new instance of BaoGuest with the given Guest ID.
    ///
    /// # Arguments
    ///
    /// * `id` - The ID of the guest.
    /// * `ram_addr` - The address of the guest's RAM.
    /// * `ram_size` - The size of the guest's RAM.
    ///
    /// # Returns
    ///
    /// * `Result<Arc<Self>>` - A Result containing an Arc-wrapped BaoGuest instance on success, or an Error on failure.
    pub fn new(id: u16, ram_addr: u64, ram_size: u64) -> Result<Arc<Self>> {
        // Create a new BaoDeviceModel instance
        let dm = match BaoDeviceModel::new(id, ram_addr, ram_size) {
            Ok(dm) => dm,
            Err(err) => {
                return Err(err);
            }
        };

        // Creates a new BaoGuest with the given Frontend ID.
        let guest = Arc::new(Self {
            id,                                           // Assigns the given ID
            dm: Mutex::new(dm), // Initializes dm as a Mutex wrapping the newly created BaoDeviceModel
            devices: Mutex::new(GuestDevices::default()), // Initializes devices with default GuestDevices and wraps it in a Mutex
            handle: Mutex::new(None), // Initializes handle as a Mutex wrapping None
            enabled: Mutex::new(false), // Initializes enabled as a Mutex wrapping false
        });

        // Creates a pointer to the same guest reference and sets up the I/O event handling thread for the BaoGuest I/O events.
        // In this case, we can have a shared ownership of the guest reference and process I/O events for the guest in a dedicated thread.
        match guest.clone().setup_io_events() {
            Ok(()) => {}
            Err(err) => {
                return Err(err);
            }
        }

        // Returns the newly created Arc-wrapped BaoGuest instance
        Ok(guest)
    }

    /// Adds a new BaoDevice with the given device ID to the collection.
    ///
    /// # Arguments
    ///
    /// * `dev_id` - The ID of the device to be added.
    /// * `dev_irq` - The IRQ of the device to be added.
    /// * `dev_addr` - The address of the device to be added.
    /// * `ram_addr` - The address of the guest's RAM.
    /// * `ram_size` - The size of the guest's RAM.
    /// * `socket_path` - The path to the socket associated with the device to be added.
    ///
    /// # Returns
    ///
    /// * `Result<Arc<BaoDevice>>` - A Result containing an Arc-wrapped BaoDevice instance on success, or an Error on failure.
    pub fn add_device(
        self: Arc<Self>,
        dev_id: u64,
        dev_irq: u64,
        dev_addr: u64,
        ram_addr: u64,
        ram_size: u64,
        socket_path: String,
    ) -> Result<Arc<BaoDevice>> {
        // Create a new BaoDevice associated with this BaoGuest instance
        let dev = BaoDevice::new(
            dev_id,
            dev_irq,
            dev_addr,
            ram_addr,
            ram_size,
            socket_path,
            self.clone(),
        )?;

        // Acquire a lock on the devices Mutex and push the newly created device into the collection
        self.devices.lock().unwrap().push(dev.clone()); // Locks the Mutex, pushes the device, and clones the device to keep the Arc reference count consistent

        // Print a message indicating the creation of the device along with the Frontend ID and device ID
        println!("Created device {} / {}", self.id, dev_id);

        // Return the newly created BaoDevice wrapped in an Arc
        Ok(dev)
    }

    /// Removes a BaoDevice with the given device ID from the collection.
    ///
    /// # Arguments
    ///
    /// * `dev_addr` - The address of the device to be removed.
    pub fn remove_device(&self, dev_addr: u64) {
        // Attempt to remove the device with the specified dev_addr from the devices collection
        let dev = self.devices.lock().unwrap().remove(dev_addr); // Locks the Mutex, removes the device with the given dev_addr, and returns it

        // Print a message indicating the removal of the device along with the Frontend ID and device ID
        println!("Removed device {} at 0x{:x}", self.id, dev_addr);

        // Call the exit method of the removed device to perform any necessary cleanup or exit actions
        dev.exit(); // Invokes the exit method of the removed device
    }

    /// Handles I/O events for the BaoGuest based on the given request.
    ///
    /// # Arguments
    ///
    /// * `req` - A mutable reference to a BaoIoRequest.
    ///
    /// # Returns
    ///
    /// * `Result<()>` - A Result containing Ok(()) on success, or an Error on failure.
    fn io_event(&self, req: &mut BaoIoRequest) -> Result<()> {
        self.devices.lock().unwrap().io_event(req)
    }

    /// Enables the BaoGuest to start processing I/O events.
    pub fn enable_io_events(&self) {
        // Acquire a lock on the enabled Mutex and set the boolean to true
        *self.enabled.lock().unwrap() = true;
    }

    /// Sets up the event handling thread for the BaoGuest.
    ///
    /// # Returns
    ///
    /// * `Result<()>` - A Result containing Ok(()) on success, or an Error on failure.
    fn setup_io_events(self: Arc<Self>) -> Result<()> {
        // Clone the BaoGuest instance
        let guest = self.clone();

        // Spawn a new thread for the BaoGuest
        *self.handle.lock().unwrap() = Some(
            Builder::new()
                .name(format!("guest {}", self.id))
                .spawn(move || {
                    // Create the I/O client
                    match guest.dm.lock().unwrap().create_io_client() {
                        Ok(()) => {}
                        Err(err) => {
                            return Err(err);
                        }
                    }

                    // Wait until the guest is enabled
                    while !*guest.enabled.lock().unwrap() {
                        std::thread::sleep(std::time::Duration::from_millis(100));
                    }

                    // Guest loop
                    loop {
                        // Attach the I/O client
                        match guest.dm.lock().unwrap().attach_io_client() {
                            Ok(()) => {}
                            Err(err) => {
                                return Err(err);
                            }
                        }
                        // Request the I/O client
                        let mut req = match guest.dm.lock().unwrap().request_io() {
                            Ok(req) => req,
                            Err(err) => {
                                return Err(err);
                            }
                        };
                        // Call the io_event method to process I/O event for the guest
                        match guest.io_event(&mut req) {
                            Ok(()) => {}
                            Err(err) => {
                                return Err(err);
                            }
                        }
                        // Notify the I/O client that the I/O request has been completed
                        match guest.dm.lock().unwrap().notify_io_completed(req) {
                            Ok(()) => {}
                            Err(err) => {
                                return Err(err);
                            }
                        }
                    }
                })
                .unwrap()
                .into(),
        );
        Ok(())
    }

    /// Checks if the BaoGuest is empty (has no devices).
    ///
    /// # Returns
    ///
    /// * `bool` - A boolean indicating whether the BaoGuest is empty.
    pub fn is_empty(&self) -> bool {
        // Acquire a lock on the devices Mutex and check if the collection is empty
        self.devices.lock().unwrap().is_empty() // Locks the Mutex and checks if the devices collection is empty
    }

    /// Exits the BaoGuest by joining the thread associated with the handle Mutex and destroying the device model.
    pub fn exit(&self) {
        // Attempt to take the handle from the handle Mutex and join the associated thread if it exists
        if let Some(handle) = self.handle.lock().unwrap().take() {
            let _ = handle.join().unwrap(); // Joins the thread associated with the handle if it exists
        }

        // Destroy the device model
        self.dm.lock().unwrap().destroy().unwrap();
    }
}
